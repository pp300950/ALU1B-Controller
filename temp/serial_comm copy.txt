#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <math.h>

#include <locale.h>

#define COM_PORT "COM3"
#define BAUD_RATE CBR_9600
#define UPLOAD_WAIT_MS 3000
#define READ_TIMEOUT_MS 1000
#define MAX_READ_BUFFER 256

HANDLE hSerial = INVALID_HANDLE_VALUE;

// ฟังก์ชันสำหรับแปลงค่าเลขฐานสิบเป็นสตริงฐานสอง
char* decimalToBinary(long long decimal) {
    if (decimal == 0) {
        char* binStr = (char*)malloc(2);
        strcpy(binStr, "0");
        return binStr;
    }

    int numBits = 0;
    long long temp = decimal;
    if (decimal < 0) temp = -decimal;
    while (temp > 0) {
        numBits++;
        temp >>= 1;
    }
    
    char* binaryString = (char*)malloc(numBits + 1);
    if (!binaryString) return NULL;
    binaryString[numBits] = '\0';
    
    long long value = (decimal < 0) ? -decimal : decimal;
    for (int i = numBits - 1; i >= 0; i--) {
        binaryString[i] = (value & 1) ? '1' : '0';
        value >>= 1;
    }
    return binaryString;
}

// ฟังก์ชันสำหรับแปลงเลขฐานสองสตริงเป็นค่าเลขฐานสิบ
long long binaryToDecimal(const char* binaryString) {
    long long decimalValue = 0;
    int length = strlen(binaryString);
    for (int i = 0; i < length; i++) {
        if (binaryString[length - 1 - i] == '1') {
            decimalValue += pow(2, i);
        }
    }
    return decimalValue;
}

// เคลียร์ buffer ของ serial port
void clearSerialBuffer() {
    if (hSerial != INVALID_HANDLE_VALUE) {
        printf("[DEBUG] กำลังล้างบัฟเฟอร์ของพอร์ตซีเรียล\n");
        PurgeComm(hSerial, PURGE_RXCLEAR | PURGE_TXCLEAR);
    }
}

// Signal handler สำหรับ cleanup
BOOL WINAPI ConsoleHandler(DWORD dwCtrlType) {
    if (dwCtrlType == CTRL_C_EVENT) {
        printf("\n[INFO] ตรวจพบ Ctrl+C. กำลังปิดโปรแกรม...\n");
        if (hSerial != INVALID_HANDLE_VALUE) {
            clearSerialBuffer();
            CloseHandle(hSerial);
        }
        ExitProcess(0);
        return TRUE;
    }
    return FALSE;
}

// ฟังก์ชันสำหรับเปิดพอร์ตและตั้งค่า
HANDLE openAndSetupSerialPort() {
    DCB dcbSerialParams = {0};
    COMMTIMEOUTS timeouts = {0};

    printf("[DEBUG] กำลังเปิดพอร์ตซีเรียล: %s\n", COM_PORT);

    int attempts = 0;
    while (attempts < 5) {
        hSerial = CreateFileA(COM_PORT, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hSerial != INVALID_HANDLE_VALUE) {
            break;
        }

        DWORD err = GetLastError();
        printf("[WARNING] เปิดพอร์ตไม่ได้ (ครั้งที่ %d). รหัสข้อผิดพลาด: %lu. กำลังลองใหม่ใน 1 วินาที...\n", attempts + 1, err);
        Sleep(1000);
        attempts++;
    }

    if (hSerial == INVALID_HANDLE_VALUE) {
        DWORD err = GetLastError();
        if (err == ERROR_FILE_NOT_FOUND) {
            printf("[ERROR] ไม่พบพอร์ตซีเรียล %s\n", COM_PORT);
        } else if (err == ERROR_ACCESS_DENIED) {
            printf("[ERROR] พอร์ตซีเรียล %s กำลังถูกใช้งานโดยโปรแกรมอื่น (เช่น Serial Monitor)\n", COM_PORT);
        } else {
            printf("[ERROR] ไม่สามารถเปิดพอร์ตซีเรียล %s ได้ รหัสข้อผิดพลาด: %lu\n", COM_PORT, err);
        }
        return INVALID_HANDLE_VALUE;
    }
    
    dcbSerialParams.DCBlength = sizeof(dcbSerialParams);
    if (!GetCommState(hSerial, &dcbSerialParams)) {
        printf("[ERROR] GetCommState ล้มเหลว\n");
        goto cleanup;
    }
    dcbSerialParams.BaudRate = BAUD_RATE;
    dcbSerialParams.ByteSize = 8;
    dcbSerialParams.StopBits = ONESTOPBIT;
    dcbSerialParams.Parity = NOPARITY;
    if (!SetCommState(hSerial, &dcbSerialParams)) {
        printf("[ERROR] SetCommState ล้มเหลว\n");
        goto cleanup;
    }

    //ตั้งค่า timeouts สำหรับการอ่านแบบวนลูป
    timeouts.ReadIntervalTimeout = 100;
    timeouts.ReadTotalTimeoutConstant = READ_TIMEOUT_MS;
    timeouts.ReadTotalTimeoutMultiplier = 0;
    timeouts.WriteTotalTimeoutConstant = 50;
    timeouts.WriteTotalTimeoutMultiplier = 10;
    if (!SetCommTimeouts(hSerial, &timeouts)) {
        printf("[ERROR] SetCommTimeouts ล้มเหลว\n");
        goto cleanup;
    }
    
    return hSerial;

cleanup:
    clearSerialBuffer();
    CloseHandle(hSerial);
    hSerial = INVALID_HANDLE_VALUE;
    return INVALID_HANDLE_VALUE;
}

// ฟังก์ชันสำหรับส่งและรับข้อมูล
bool sendAndReceiveData(const char* dataToSend, int* resultOutput, int* carryOutput) {
    if (hSerial == INVALID_HANDLE_VALUE) {
        printf("[ERROR] Handle ซีเรียลไม่ถูกต้อง\n");
        return false;
    }

    DWORD bytesWritten = 0;
    DWORD bytesRead = 0;
    char readBuffer[MAX_READ_BUFFER] = {0};
    
    size_t len = strlen(dataToSend);
    if (len == 0 || dataToSend[len - 1] != '\n') {
        printf("[ERROR] ข้อมูลที่จะส่งต้องลงท้ายด้วยอักขระขึ้นบรรทัดใหม่ (\\n)\n");
        return false;
    }

    DWORD dataSize = (DWORD)len;
    DWORD totalWritten = 0;
    printf("[DEBUG] กำลังเขียนข้อมูล %lu ไบต์: \"%s\"\n", dataSize, dataToSend);
    while (totalWritten < dataSize) {
        if (!WriteFile(hSerial, dataToSend + totalWritten, dataSize - totalWritten, &bytesWritten, NULL)) {
            printf("[ERROR] WriteFile ล้มเหลว รหัสข้อผิดพลาด: %lu\n", GetLastError());
            return false;
        }
        totalWritten += bytesWritten;
    }
    
    clearSerialBuffer();

    DWORD totalBytesRead = 0;
    do {
        if (totalBytesRead >= MAX_READ_BUFFER - 1) {
            break;
        }
        if (ReadFile(hSerial, readBuffer + totalBytesRead, MAX_READ_BUFFER - 1 - totalBytesRead, &bytesRead, NULL) && bytesRead > 0) {
            totalBytesRead += bytesRead;
        } else {
            DWORD err = GetLastError();
            if (err == ERROR_SUCCESS) {
                break;
            } else if (err != ERROR_IO_PENDING && err != ERROR_OPERATION_ABORTED) {
                return false;
            }
            break;
        }
    } while (true);
    readBuffer[totalBytesRead] = '\0';
    if (totalBytesRead > 0) {
        printf("[INFO] ได้รับข้อมูล %lu ไบต์: %s\n", totalBytesRead, readBuffer);
        if (sscanf(readBuffer, "%d %d", resultOutput, carryOutput) == 2) {
            return true;
        } else {
            printf("[ERROR] รูปแบบข้อมูลที่ได้รับไม่ถูกต้อง: \"%s\"\n", readBuffer);
            return false;
        }
    } else {
        printf("[DEBUG] ไม่ได้รับข้อมูลหรืออ่านข้อมูลหมดเวลาแล้ว\n");
        return false;
    }
}

// ฟังก์ชันสำหรับ Invert (หา 1's Complement)
char* invertBinary(const char* binaryString) {
    size_t len = strlen(binaryString);
    char* inverted = (char*)malloc(len + 1);
    if (!inverted) return NULL;
    
    for (size_t i = 0; i < len; i++) {
        inverted[i] = (binaryString[i] == '0') ? '1' : '0';
    }
    inverted[len] = '\0';
    return inverted;
}

// ฟังก์ชันสำหรับบวกและลบเลขฐานสอง
char* binaryOp(const char* num1, const char* num2, const char* op, bool *isNeg) {
    char* B_op = (char*)num2;
    char* B_inverted = NULL;
    int op_mode = 0; // 0 = ADD, 1 = SUB

    if (strcmp(op, "ADD") == 0) {
        op_mode = 0;
    } else if (strcmp(op, "SUB") == 0) {
        op_mode = 1;
        B_inverted = invertBinary(num2);
        B_op = B_inverted;
    } else {
        printf("[ERROR] คำสั่งไม่ถูกต้อง\n");
        if (B_inverted) free(B_inverted);
        return NULL;
    }

    size_t len1 = strlen(num1);
    size_t len2 = strlen(B_op);
    size_t maxLen = (len1 > len2) ? len1 : len2;

    char* result = (char*)malloc(sizeof(char) * (maxLen + 2)); 
    if (result == NULL) {
        printf("[ERROR] Memory allocation failed\n");
        if (B_inverted) free(B_inverted);
        return NULL;
    }
    result[maxLen + 1] = '\0';

    int carry_in = (op_mode == 1) ? 1 : 0;
    int alu_result, alu_carry;

    for (int i = 0; i < maxLen; i++) {
        int bit1 = (i < len1) ? num1[len1 - 1 - i] - '0' : 0;
        int bit2 = (i < len2) ? B_op[len2 - 1 - i] - '0' : 0;

        printf("\n[STEP %d] กำลังคำนวณบิต: A=%d, B=%d, Carry-in=%d\n", i + 1, bit1, bit2, carry_in);
        
        char command[20];
        // ใช้ MuxCode 001 (ADD) เสมอ
        snprintf(command, sizeof(command), "001 0 %d %d\n", bit1, bit2);
        
        if (sendAndReceiveData(command, &alu_result, &alu_carry)) {
            int sum_with_carry_in = alu_result ^ carry_in;
            int new_carry = alu_carry | (alu_result & carry_in);
            
            result[maxLen - i] = sum_with_carry_in + '0';
            carry_in = new_carry;

            printf("[INFO] ALU output (from 001): Sum=%d, Carry=%d\n", alu_result, alu_carry);
            printf("[INFO] Final PC logic: Sum with Carry-in=%d, New Carry-out=%d\n", sum_with_carry_in, new_carry);
        } else {
            printf("[ERROR] Failed to perform operation for bit %d\n", i);
            if (B_inverted) free(B_inverted);
            free(result);
            return NULL;
        }
    }

    if (op_mode == 1) {
        // สำหรับการลบ (2's complement) ถ้ามี carry-out = 1 แสดงว่าผลลัพธ์เป็นบวก
        // ถ้าไม่มี carry-out (carry_in = 0) แสดงว่าผลลัพธ์เป็นลบ
        if (carry_in > 0) {
            memmove(result, result + 1, maxLen + 1);
            *isNeg = false;
        } else {
            printf("[INFO] ผลลัพธ์เป็นลบ. กำลังหา 2's complement\n");
            char* temp = invertBinary(result + 1);
            // บวก 1 เข้าไปใน 1's complement เพื่อหา 2's complement
            int len_temp = strlen(temp);
            int add_carry = 1;
            for(int i = len_temp - 1; i >= 0; i--) {
                if (add_carry == 0) break;
                if (temp[i] == '0') {
                    temp[i] = '1';
                    add_carry = 0;
                } else {
                    temp[i] = '0';
                    add_carry = 1;
                }
            }
            free(result);
            result = temp;
            *isNeg = true;
        }
    } else { // โหมดบวก
        if (carry_in > 0) {
            result[0] = '1';
            printf("\n[STEP %d] เพิ่มตัวทดสุดท้าย: %d\n", maxLen + 1, carry_in);
        } else {
            memmove(result, result + 1, maxLen + 1);
        }
        *isNeg = false;
    }
    
    if (B_inverted) free(B_inverted);
    return result;
}

// เรียก arduino-cli
bool executeArduinoCLI(const char* cliPath, const char* board, const char* port, const char* inoPath) {
    char commandLine[1024];
    snprintf(commandLine, sizeof(commandLine),
             "\"%s\" compile --upload -b %s -p %s \"%s\"",
             cliPath, board, port, inoPath);

    printf("[INFO] กำลังรันคำสั่ง Arduino CLI...\n");
    printf("[DEBUG] คำสั่ง: %s\n", commandLine);

    STARTUPINFOA si = { sizeof(si) };
    PROCESS_INFORMATION pi;

    if (!CreateProcessA(NULL, commandLine, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
        printf("[ERROR] CreateProcess ล้มเหลว รหัสข้อผิดพลาด: %lu\n", GetLastError());
        return false;
    }

    WaitForSingleObject(pi.hProcess, INFINITE);

    DWORD exitCode;
    GetExitCodeProcess(pi.hProcess, &exitCode);

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    if (exitCode != 0) {
        printf("[ERROR] อัปโหลดโค้ด Arduino ล้มเหลว รหัสออก: %lu\n", exitCode);
        return false;
    }

    printf("[INFO] อัปโหลดโค้ด Arduino สำเร็จแล้ว\n");
    return true;
}

int main() {
    SetConsoleOutputCP(CP_UTF8);
    
    const char* arduinoCliPath = "C:\\Users\\Administrator\\Desktop\\arduino-cli.exe";
    const char* boardType = "arduino:avr:uno";
    const char* inoFilePath = "C:\\Users\\Administrator\\Desktop\\ALU4B-Controller/ALU4B-Controller/ALU4B-Controller.ino";

    SetConsoleCtrlHandler(ConsoleHandler, TRUE);

    if (!executeArduinoCLI(arduinoCliPath, boardType, COM_PORT, inoFilePath)) {
        return 1;
    }

    printf("[INFO] กำลังรอให้บอร์ดพร้อมใช้งานเป็นเวลา %d มิลลิวินาที...\n", UPLOAD_WAIT_MS);
    Sleep(UPLOAD_WAIT_MS);

    hSerial = openAndSetupSerialPort();
    if (hSerial == INVALID_HANDLE_VALUE) {
        return 1;
    }
    
    char op[10];
    long long dec1, dec2;

    printf("โปรดป้อนคำสั่ง (ADD/SUB) ตามด้วยเลขฐานสิบสองตัว (เช่น ADD 23 15):\n");
    if (scanf("%s %lld %lld", op, &dec1, &dec2) != 3) {
        printf("[ERROR] รูปแบบอินพุตไม่ถูกต้อง\n");
        CloseHandle(hSerial);
        return 1;
    }

    char* num1 = decimalToBinary(dec1);
    char* num2 = decimalToBinary(dec2);

    if (!num1 || !num2) {
        printf("[ERROR] Memory allocation failed\n");
        if(num1) free(num1);
        if(num2) free(num2);
        CloseHandle(hSerial);
        return 1;
    }

    bool isNegative = false;
    char* result = binaryOp(num1, num2, op, &isNegative);

    if (result != NULL) {
        printf("\n--- ผลลัพธ์สุดท้าย ---\n");
        printf("คำสั่ง: %s\n", op);
        
        long long decResult = binaryToDecimal(result);

        printf("  %s (ฐาน 2) = %lld (ฐาน 10)\n", num1, dec1);
        
        if (strcmp(op, "SUB") == 0) {
            printf("- %s (ฐาน 2) = %lld (ฐาน 10)\n", num2, dec2);
        } else {
            printf("+ %s (ฐาน 2) = %lld (ฐาน 10)\n", num2, dec2);
        }
        
        printf("---------------------\n");
        
        if (isNegative) {
            printf("  -%s (ฐาน 2) = -%lld (ฐาน 10)\n", result, decResult);
        } else {
            printf("  %s (ฐาน 2) = %lld (ฐาน 10)\n", result, decResult);
        }
        
        free(result);
        free(num1);
        free(num2);
    } else {
        printf("[ERROR] ไม่สามารถคำนวณได้\n");
        if(num1) free(num1);
        if(num2) free(num2);
    }

    clearSerialBuffer();
    CloseHandle(hSerial);
    printf("[DEBUG] ปิดพอร์ตซีเรียลแล้ว เย่ๆ\n");

    return 0;
}